/*! \fn			void INRUSH_Init(void)
 *  \brief 		Initialization of the inrush module
 *  \param 		None
 *  \exception (None non-reentrant code)
 *  \return 	None
 */
void INRUSH_Init(void)
{
   GPIO_InrushInit();
   g_sInrush.u16CallTick = INRUSH_TICK;
   g_sInrush.u16InrushCnt = 0;
   g_sInrush.bRelayState = FALSE;
}

/*! \fn        BOOLEAN INRUSH_Handler(FLOAT32 f32Udc)
 *  \brief     Inrush handler, this handler function should be called in task
 *  \param     f32Udc: Udc voltage
 *  \exception (None non-reentrant code)
 *  \return    TRUE for inrush relay on
 */
BOOLEAN INRUSH_Handler(FLOAT32 f32Udc)
{
   if((!g_sInrush.bRelayState) && (f32Udc > INRUSH_ON_VOLTAGE))
   {
      g_sInrush.u16InrushCnt++;

      if(g_sInrush.u16InrushCnt > INRUSH_CNT)
      {
         GPIO_InrushControl(TRUE);
         g_sInrush.bRelayState = TRUE;
      }
   }
   else if(g_sInrush.bRelayState && (f32Udc < INRUSH_OFF_VOLTAGE))
   {
      if(0 == g_sInrush.u16InrushCnt)
      {
         GPIO_InrushControl(FALSE);
         g_sInrush.bRelayState = FALSE;
      }

      g_sInrush.u16InrushCnt--;
   }

   return g_sInrush.bRelayState;
}

//-------------------- private functions ------------------------------------
/*! \fn			void function(UNSIGNED32 u32Param1)
 *  \brief 		Description of this function
 *  \param 		param1: Description of parameter
 *  \param 		param2: Description of parameter
 *  \exception (None non-reentrant code)
 *  \return 	TRUE: success FALSE: unsuccess
 */
